原文：[虚调用_百度百科](https://baike.baidu.com/item/%E8%99%9A%E8%B0%83%E7%94%A8/18842657)

虚调用是相对于实调用而言，它的本质是动态联编。在发生函数调用的时候，如果函数的入口地址是在编译阶段静态确定的，就是是实调用。反之，如果函数的入口地址要在运行时通过查询虚函数表的方式获得，就是虚调用。

### 函数的实调用

#### 不通过指针或者引用调用虚函数

虚调用不能简单的理解成“对虚函数的调用”，因为对虚函数的调用很有可能是实调用。
```cpp
#include <iostream>
using namespace std;

class A{
public:
    virtual void show(){
        cout<<"A::show()"<<endl;
    }
};

class B:public A{
public:
    void show(){
        cout<<"B::show()"<<endl;
    }
};

int main(){
    B b;
    b.show();    // 1
    static_cast<A>(b).show();  // 2
    A a = b;
    a.show();    // 3
    return 0;
}
```
运行结果：
```
B::show()
A::show()
A::show()
```
通过运行结果与反汇编可以看到，以上3种方式在调用虚函数时，函数指针在编译阶段就已经确定，属于实调用。对于第2、3种情况，`static_cast<A>(b)`与`a`对于编译器来说，都是“纯粹”的类`A`的实例，与类`B`毫无关系，所以它们所调用的虚函数的指针在编译阶段就可以确定。

部分反汇编结果：
```cpp
...
20	    b.show();
   0x0040147e <+30>:	lea    -0x10(%ebp),%eax
   0x00401481 <+33>:	mov    %eax,%ecx
   0x00401483 <+35>:	call   0x403c14 <B::show()>

21	    static_cast<A>(b).show();
  0x00401488 <+40>:	lea    -0xc(%ebp),%eax
  0x0040148b <+43>:	lea    -0x10(%ebp),%edx
  0x0040148e <+46>:	mov    %edx,(%esp)
  0x00401491 <+49>:	mov    %eax,%ecx
  0x00401493 <+51>:	call   0x403bfc <A::A(A const&)>
  0x00401498 <+56>:	sub    $0x4,%esp
  0x0040149b <+59>:	lea    -0xc(%ebp),%eax
  0x0040149e <+62>:	mov    %eax,%ecx
  0x004014a0 <+64>:	call   0x403bc8 <A::show()>
...
23	    a.show();
   0x004014b8 <+88>:	lea    -0x14(%ebp),%eax
   0x004014bb <+91>:	mov    %eax,%ecx
   0x004014bd <+93>:	call   0x403bc8 <A::show()>
```

#### 构造函数和析构函数中调用虚函数

在构造函数和析构函数中调用虚函数，对虚函数的调用实际上是实调用。因为从概念上说，在一个对象的构造函数运行完毕之前，这个对象还没有完全诞生，所以在构造函数中调用虚函数，实际上都是实调用。

析构时，在销毁一个对象时，先调用该类所属类的析构函数，然后再调用其基类的析构函数。所以，在调用基类的析构函数时，派生类已经被析构了，派生类数据成员已经失效，无法动态的调用派生类的虚函数。

```cpp
#include <iostream>
using namespace std;

class A{
public:
    virtual void show(){
        cout<<"A::show()"<<endl;
    }
    A(){
        cout<<"===>A()"<<endl;
        show();
        cout<<"<===A()"<<endl;
    }
    virtual ~A(){
        cout<<"===>~A()"<<endl;
        show();
        cout<<"<===~A()"<<endl;
    }
};

class B:public A{
public:
    void show(){
        cout<<"B::show()"<<endl;
    }
    B(){
        cout<<"===>B()"<<endl;
        show();
        cout<<"<===B()"<<endl;
    }
    ~B(){
        cout<<"===>~B()"<<endl;
        show();
        cout<<"<===~B()"<<endl;
    }
};

int main(){
    A* pa=new B();
    pa->show();
    delete pa;
}
```
运行结果：
```cpp
===>A()
A::show()
<===A()
===>B()
B::show()
<===B()
B::show()
===>~B()
B::show()
<===~B()
===>~A()
A::show()
<===~A()
```
从运行结果可以看到，在构造类`B`的实例时，会先调用基类`A`的构造函数，如果在构造函数中对`show()`的调用是虚调用，那么应该打印出`B::show()`，但运行结果却并不是如此。析构也一样，对虚函数的调用都是实调用。

但我们也应该知道，由于我们将基类的析构函数声明为虚函数，当对`pa`执行`delete`操作时，对于析构函数的调用属于虚调用，也就是说，析构函数的指针是从虚函数表中获取的，若我们已经在类`B`中定义了析构函数，则此时获取的是类`B`的析构函数指针，这样就使得所有资源都可以成功释放。

部分反汇编结果：
```cpp
40	    pa->show();
   0x00401489 <+41>:	mov    0x1c(%esp),%eax
   0x0040148d <+45>:	mov    (%eax),%eax
   0x0040148f <+47>:	mov    (%eax),%eax
   0x00401491 <+49>:	mov    0x1c(%esp),%edx
   0x00401495 <+53>:	mov    %edx,%ecx
   0x00401497 <+55>:	call   *%eax

41	    delete pa;
   0x00401499 <+57>:	cmpl   $0x0,0x1c(%esp)
   0x0040149e <+62>:	je     0x4014b3 <main()+83>
   0x004014a0 <+64>:	mov    0x1c(%esp),%eax
   0x004014a4 <+68>:	mov    (%eax),%eax
   0x004014a6 <+70>:	add    $0x8,%eax
   0x004014a9 <+73>:	mov    (%eax),%eax
   0x004014ab <+75>:	mov    0x1c(%esp),%edx
   0x004014af <+79>:	mov    %edx,%ecx
   0x004014b1 <+81>:	call   *%eax
```

### 函数的虚调用

#### 通过指针或者引用调用虚函数

当通过指针或者引用调用虚函数时，虚函数的指针在编译阶段无法确定，是在运行阶段从虚函数表中的确定位置处获取的。

```cpp

```
