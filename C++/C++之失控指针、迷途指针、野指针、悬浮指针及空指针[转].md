原文：[C++基础---失控指针、迷途指针、野指针、悬浮指针及空指针](http://blog.csdn.net/cainv89/article/details/47209449)

指针就是用来保存内存地址的变量，因此定义了一个指针后就要给它赋一个地址，或初始化为空指针。使用`delete`释放掉指针指向的内存后，不再使用该指针，将其置为空指针。

**1. 失控指针**

* 失控指针：也称迷途指针、野指针、悬浮指针，**指的是不指向任何合法的对象的指针，可以指向任何地址，并且对该地址的数值进行修改或删除，可能会造成意想不到的后果。**

**2. 迷途指针（悬浮指针）**

* 迷途指针：**当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针称为迷途指针。**
* 若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。
* 这种类型的程序错误，不容易找到问题的原因，通常会导致段错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。

**3. 野指针**

* 野指针：**未被初始化的指针**，野指针所导致的错误和迷途指针非常相似，但野指针的问题更容易被发现。

**4. 空指针**

* 空指针：就是一个**被赋值为0的指针**，它不指向任何的对象或者函数。

**5. 重踏指针**

* 重踏指针：**被释放后的指针不置为空指针，不再指向任何合法的内存，它仍可能指向原来的内存块，此时再定义一个新的指针，两个指针都指向同一块内存。**
* 经典重踏指针程序实例：
```cpp
#include <iostream>
using namespace std;
typedef unsigned short int USHORT;
int main() {
    USHORT *pShort = new USHORT;
    *pShort = 10;
    cout<<"pShort = "<<pShort<<endl;
    cout<<"*pShort = "<<*pShort<<endl;
    delete pShort;  // 释放pShort指针指向的内存空间

//    pShort = 0;  // 把这句注释掉，pShort将成为一个重踏指针

    long *pLong = new long;  // pLong指针指向的是pShort原来指向的内存块
    *pLong = 90000;
    cout<<"pLong = "<<pLong<<endl;
    cout<<"*pLong = "<<*pLong<<endl;

    *pShort = 20;
    cout<<"*pShort = "<<*pShort<<endl;
    cout<<"*pLong = "<<*pLong<<endl;
    delete pLong;
    return 0;
}
```
运行结果：
```
pShort = 0x4d11c8
*pShort = 10
pLong = 0x4d11c8
*pLong = 90000
*pShort = 20
*pLong = 65556
```
